### 프로퍼티와 매개변수의 차이

**프로퍼티**는 클래스의 속성을 나타내며, 클래스의 인스턴스와 연관된 데이터를 저장합니다. 프로퍼티는 클래스의 필드와 대응되며, 게터와 세터를 통해 값을 읽거나 쓸 수 있습니다.

**매개변수**는 함수나 생성자에서 사용되며, 함수 호출 시 전달되는 값을 받기 위해 사용합니다. 매개변수는 함수 내에서만 유효합니다.

### null을 허용하는 변수 타입 선언 시 기본값 설정

`?`를 사용하여 변수에 `null`을 허용할 수 있으나, 이후에 `= null`을 통해 기본값을 `null`로 설정해야 하는 것은 아닙니다. 예를 들어:

```kotlin
val age: Int? = null
```

여기서 `= null`을 빼고 다음과 같이 선언한다면, 객체를 생성할 때 반드시 값을 제공해야 합니다:

```kotlin
val age: Int?
```

기본값을 변수 선언 시에 설정하게 되면, 객체 생성 시 값을 제공하지 않아도 기본값을 사용할 수 있으며, 생성자를 통해 초기화해야 할 필요도 사라지게 됩니다.

자바에서는 다음과 같이 변수 이름 뒤에 기본값이 나옵니다:

```java
private String name = "test";
```

코틀린에서는 변수 타입을 이름 뒤에 사용합니다:

```kotlin
val name: String = "test"
```

사실상 변수 타입과 이름의 순서가 바뀌는 것만 빼면 초기값 설정은 동일합니다.

### 예시 코드 분석

```kotlin
val oldest = persons.maxByOrNull { it.age ?: 0 }
```

`maxByOrNull`은 컬렉션에서 최대값을 가진 요소를 찾으며, 만약 컬렉션이 비어 있으면 `null`을 반환합니다. 람다식은 각 `Person`의 `age` 프로퍼티를 기준으로 최대값을 찾으며, `age`가 `null`인 경우에는 `0`으로 대체하여 비교합니다. `maxByOrNull`은 본질적으로 람다식을 사용하여 컬렉션의 각 요소에 대한 기준을 제공하는 함수이기 때문에, 람다식을 사용하지 않고 `maxByOrNull`을 사용하는 것은 불가능합니다.

여기서 `it`은 람다식 내부에서 현재 요소를 참조하는데 사용됩니다. 즉, `persons` 리스트(컬렉션)의 `Person` 객체를 가리킵니다. 따라서 `it.age`는 현재 `Person` 객체의 `age` 프로퍼티를 참조합니다.

`?:`는 엘비스 연산자로, `null` 값이 발생할 수 있는 상황에서 기본값을 제공하는 데 사용됩니다.

## Kotlin의 주요 특성

### 타겟 플랫폼

서버사이드, 안드로이드, 혹은 어디든 자바가 사용되는 곳에서 Kotlin을 사용할 수 있습니다. `Kotlin/JS`를 통해 웹 페이지를 제작할 때도 Kotlin을 사용할 수 있습니다. 이는 Kotlin으로 만든 앱을 기반으로 웹 페이지를 만들고자 할 때 유용할 수 있습니다.

### 정적 타입 지정 언어

정적 타입 지정 언어란, 모든 프로그램 구성 요소의 타입을 컴파일 시점에 알 수 있고 프로그램 안에서 객체의 필드나 메서드를 사용할 때마다 컴파일러가 타입을 검증해준다는 뜻입니다.

동적 타입 지정 언어의 경우, 변수의 타입이 런타임에 결정됩니다. 즉, 변수 선언 시 명시적으로 지정되는 것이 아니라 변수에 할당되는 값에 따라 타입이 결정된다는 것입니다. (예: 파이썬, 자바스크립트 등)

#### 장점
- 유연성, 간결함, 빠른 프로토타이핑
#### 단점
- 타입 오류 가능성, 디버깅 어려움, 성능 문제

Kotlin은 타입 추론을 지원하기 때문에 변수 선언 시 타입을 생략할 수 있습니다. 컴파일러가 자동으로 변수의 타입을 결정합니다. `Any` 타입을 사용하면 동적 타입을 사용할 수 있습니다.

> 컴파일이 완료된 후, 프로그램이 실행되는 동안 발생하는 오류를 런타임 오류라고 합니다. 런타임 오류는 프로그램이 정상적으로 컴파일되고 실행을 시작한 이후에 발생합니다. 이러한 오류는 실행 시 특정 조건이나 입력에 의해 트리거될 수 있습니다. 예를 들어 Null Pointer Exception 에러가 런타임 오류의 예시입니다. 파이썬의 경우 타입을 동적으로 결정하기 때문에, 만약 숫자를 문자열로 나누려고 한다면 TypeError가 발생합니다.

Kotlin의 정적 타입 시스템 덕분에 많은 타입 관련 오류를 컴파일 타임에 발견할 수 있습니다. 단, 이는 타입 오류가 전혀 발생하지 않는다는 의미는 아닙니다. NullPointerException과 같은 예외는 여전히 발생할 수 있습니다.

### 정적 타입 지정 언어의 장점

- **성능**: 실행 시점에 어떤 메서드를 호출할지 알아내는 과정이 필요 없으므로 메서드 호출이 더 빠릅니다. (정적 타입 지정 언어에서는 컴파일 타임에 메서드 호출이 결정되기 때문에)
- **신뢰성**: 컴파일러가 프로그램의 정확성을 검증하기 때문에 실행 시 프로그램이 오류로 중단될 가능성이 더 적어집니다.
- **유지보수성**: 코드에서 다루는 객체가 어떤 타입에 속하는지 알 수 있기 때문에 처음 보는 코드를 다룰 때 더 쉽습니다.
- **도구 지원**: 정적 타입 지정을 통해 더 안전하게 리팩토링할 수 있고, 도구는 더 정확한 코드 완성 기능을 제공할 수 있습니다.

Kotlin의 타입 추론은 런타임 시점에 추론하는 것이 아니라 컴파일 시점에 추론합니다. (중요!)

Kotlin의 타입 시스템에서 중요한 새로운 개념 중 하나는 Nullable 타입 지원입니다. 이는 잠재적인 NullPointerException을 컴파일 타임에 감지하게 해줍니다. 또한 Kotlin은 함수 타입을 지원합니다.

### 함수형 프로그래밍과 객체지향 프로그래밍

함수형 프로그래밍은 프로그래밍 패러다임 중 하나로, 프로그램을 함수의 조합으로 구성하는 방식을 강조합니다. 함수를 값으로 다루거나, 다른 함수의 인자로 전달하고, 함수에서 반환할 수 있습니다. 이 패러다임은 수학적 함수의 개념에 기초하여, 불변성과 순수함수를 중시합니다.

#### 함수형 프로그래밍의 핵심 개념

- **일급 시민(first-class) 함수**: 함수를 일반 값처럼 다룰 수 있습니다.
  - 함수를 변수에 저장
  - 함수를 인자로 다른 함수에 전달
  - 함수에서 새로운 함수를 만들어서 반환
- **불변성**: 함수형 프로그래밍에서는 불변 객체를 사용하여 프로그램을 작성합니다.
- **부수효과 없음**: 입력이 같으면 항상 같은 출력이 나오는 순수 함수를 사용합니다.
  - 함수 외부의 상태나 변수를 변경하지 않습니다.
  - 함수 외부나 다른 바깥 환경과 상호작용하지 않는 순수 함수를 사용합니다.

> Q. 함수 외부의 상태나 변수를 변경한다는 것은 어떤 의미인가?
> 함수 외부의 상태나 변수를 변경한다는 것은 함수 내부에서 전역 변수나 함수 외부에 정의된 객체의 상태를 변경하거나, I/O 작업을 수행하는 것을 의미합니다.
> - 전역 변수 값 변경
> - 객체의 상태 변경 (외부의 데이터 클래스를 인수로 받아서 객체의 상태를 변경하는 경우)
> 함수의 실행이 외부 상태에 영향을 끼친다는 것은 **부작용(Side-effect)**을 일으킨다는 것을 의미합니다.

#### 함수형 프로그래밍의 이점

- **간결성**: 함수를 값처럼 활용하므로 더 강력한 추상화를 가능하게 합니다.
  - 함수를 값처럼 사용하므로 코드를 더 모듈화하고, 중복을 줄임으로써 추상화 수준을 높일 수 있습니다.
  - 공통 부분을 따로 함수로 뽑아내고 서로 다른 세부사항을 인자로 전달합니다. 인자 자체도 함수가 될 수 있습니다.
- **다중 스레드에서 안전**: 불변 데이터 구조를 사용하기 때문에 여러 스레드가 동시에 읽고 쓰는 상황에서도 상태 변화가 일어나지 않아 데이터 무결성을 보장할 수 있습니다.
  - 코틀린에서는 리스트, 셋 등에 대해 불변 데이터 구조와 가변 데이터 구조 둘 다 지원합니다.
- **테스트하기 쉽다**: 순수 함수는 준비 코드 없이 독립적으로 테스트할 수 있습니다.
  - 외부 상태에 상관 없기 때문에 해당 함수와 입력 값만 있다면 테스트가 가능하며, 전역 상태도 신경 쓸 필요가 없습니다.

> 함수형 프로그래밍은 순수 함수를 많이 사용하는 것을 권장하지만, 현실적인 프로그램에서는 때때로 부작용을 일으키는 함수가 필요합니다. 따라서 아예 사용하지 않는 것이라기보다는 가능한 한 부작용을 일으키는 코드를 최소화하고, 이러한 부작용을 관리하는 방법을 설계하는 것이 목표입니다.

###